<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link
            rel="icon"
            href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>
            ☀️
            </text></svg>"
        />
        <title>uwaterloo sunshines</title>
    </head>
    <body>
        <div id="container-wrapper">
            <div id="container"></div>
        </div>
    </body>
    <style>
        #container-wrapper {
            width: 100vw;
            height: 100vh;

            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
    <script type="module">
        const getCleanData = async () => {
            const INPUT_PATH = './data joined/joined clean.csv'
            const responseStr = await fetch(INPUT_PATH).then((response) => response.text())
            const header = responseStr.split('\n')[0].split(';')
            const body = responseStr
                .split('\n')
                .slice(1)
                .map((line) => line.split(';'))

            const cleanData = []
            body.forEach((line) => {
                const cleanObj = {}

                const salary = line[3]
                const taxbenefits = line[4]
                const papercount = line[5]
                const citationcount = line[6]
                const hindex = line[7]
                const missingField = !salary || !taxbenefits || !papercount || !citationcount || !hindex
                if (missingField) {
                    return
                }

                // get total comp
                const cleanSalary = parseFloat(salary.replace(/\$/g, '').replace(/,/g, ''))
                const cleanTaxBenefits = parseFloat(taxbenefits.replace(/\$/g, '').replace(/,/g, ''))
                if (isNaN(cleanSalary) || isNaN(cleanTaxBenefits)) {
                    return
                }
                if (cleanSalary < 100_000) {
                    return
                }
                const totalcomp = cleanSalary + cleanTaxBenefits
                cleanObj.totalcomp = totalcomp

                // get performance
                const cleanPaperCount = parseInt(papercount)
                const cleanCitationCount = parseInt(citationcount)
                const cleanHIndex = parseInt(hindex)
                if (isNaN(cleanPaperCount) || isNaN(cleanCitationCount) || isNaN(cleanHIndex)) {
                    return
                }
                cleanObj.papercount = cleanPaperCount
                cleanObj.citationcount = cleanCitationCount
                cleanObj.hindex = cleanHIndex

                cleanData.push(cleanObj)
            })
            return cleanData
        }

        import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm'
        async function main() {
            const cleanData = await getCleanData()
            // clean data format: { .totalcomp, .papercount, .citationcount, .hindex }

            // ----- d3 parallel coordinates -----
            const leftMargin = 175
            const width = 900
            const height = 700
            const yAxisPadding = 200

            const svg = d3.select('#container').append('svg').attr('width', width).attr('height', height)

            const dimensions = {
                totalcomp: { min: d3.min(cleanData, (d) => d.totalcomp), max: d3.max(cleanData, (d) => d.totalcomp) },
                papercount: { min: d3.min(cleanData, (d) => d.papercount), max: d3.max(cleanData, (d) => d.papercount) },
                citationcount: { min: d3.min(cleanData, (d) => d.citationcount), max: d3.max(cleanData, (d) => d.citationcount) },
                hindex: { min: d3.min(cleanData, (d) => d.hindex), max: d3.max(cleanData, (d) => d.hindex) },
            }

            const y = {}
            for (let dimension in dimensions) {
                y[dimension] = d3.scaleLinear().domain([dimensions[dimension].min, dimensions[dimension].max]).range([height, 0])
            }

            svg.selectAll('.axis')
                .data(Object.keys(dimensions))
                .enter()
                .append('g')
                .attr('class', 'axis')
                .attr('transform', (d, i) => `translate(${i * yAxisPadding + leftMargin},0)`)
                .each(function (d) {
                    d3.select(this).call(d3.axisLeft().scale(y[d]))
                })

            const line = d3
                .line()
                .defined((d) => !isNaN(d[1]))
                .x((d, i) => i * yAxisPadding + leftMargin)
                .y((d) => y[d[0]](d[1]))

            svg.selectAll('.line')
                .data(cleanData)
                .enter()
                .append('path')
                .attr('class', 'line')
                .attr('d', (d) => line(Object.keys(dimensions).map((p) => [p, d[p]])))
                .style('stroke', 'steelblue')
                .style('stroke-width', 1)
                .style('fill', 'none')
        }
        main()
    </script>
</html>
