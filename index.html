<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link
            rel="icon"
            href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>
            ☀️
            </text></svg>"
        />
        <title>uwaterloo's sunshines</title>
    </head>
    <body>
        <header>
            <h1>academic performance of uwaterloo's sunshines</h1>
            <p>
                assuming that academic performance can be measured by the traditional metrics of the number of papers published, the number of citations, and
                the h-index, then we can use these metrics to compare the academic performance of uwaterloo's sunshines (people who make more than $100,000 a
                year).
            </p>
            <br />
            <div>
                <input type="checkbox" id="toggle1" />
                <label for="toggle1">low</label>

                <input type="checkbox" id="toggle2" />
                <label for="toggle2">mid</label>

                <input type="checkbox" id="toggle3" />
                <label for="toggle3">high</label>
            </div>
        </header>

        <div id="container-wrapper">
            <div id="container"></div>
        </div>
    </body>
    <style>
        /* disable scrolling */
        body {
            overflow: hidden;
        }
        header {
            transform: translateY(200px);
            text-align: center;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;

            margin-left: 3rem;
        }
        header p {
            max-width: 800px;
            margin: 0 auto;
        }
        #container-wrapper {
            width: 100vw;
            height: 100vh;

            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
    <script type="module">
        const getCleanData = async () => {
            const INPUT_PATH = './data joined/joined clean.csv'
            const responseStr = await fetch(INPUT_PATH).then((response) => response.text())
            const header = responseStr.split('\n')[0].split(';')
            const body = responseStr
                .split('\n')
                .slice(1)
                .map((line) => line.split(';'))

            const cleanData = []
            body.forEach((line) => {
                const cleanObj = {}

                const salary = line[3]
                const taxbenefits = line[4]
                const papercount = line[5]
                const citationcount = line[6]
                const hindex = line[7]
                const missingField = !salary || !taxbenefits || !papercount || !citationcount || !hindex
                if (missingField) {
                    return
                }

                // get total comp
                const cleanSalary = parseFloat(salary.replace(/\$/g, '').replace(/,/g, ''))
                const cleanTaxBenefits = parseFloat(taxbenefits.replace(/\$/g, '').replace(/,/g, ''))
                if (isNaN(cleanSalary) || isNaN(cleanTaxBenefits)) {
                    return
                }
                if (cleanSalary < 100_000) {
                    return
                }
                const totalcomp = cleanSalary + cleanTaxBenefits
                cleanObj.totalcomp = totalcomp

                // get performance
                const cleanPaperCount = parseInt(papercount)
                const cleanCitationCount = parseInt(citationcount)
                const cleanHIndex = parseInt(hindex)
                if (isNaN(cleanPaperCount) || isNaN(cleanCitationCount) || isNaN(cleanHIndex)) {
                    return
                }
                cleanObj.papercount = cleanPaperCount
                cleanObj.citationcount = cleanCitationCount
                cleanObj.hindex = cleanHIndex

                cleanData.push(cleanObj)
            })
            return cleanData
        }

        const checkboxes = document.querySelectorAll('input[type="checkbox"]')
        // add listeners
        checkboxes.forEach((checkbox) => {
            checkbox.addEventListener('change', (event) => {
                const checked = event.target.checked
                const id = event.target.id
                // min: 100230.36
                // max: 475454.37

                if (id === 'toggle1') {
                    console.log('toggle1 is now', checked)
                } else if (id === 'toggle2') {
                    console.log('toggle2 is now', checked)
                } else if (id === 'toggle3') {
                    console.log('toggle3 is now', checked)
                }
            })
        })

        // ----- d3 parallel coordinates -----
        import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm'
        async function main() {
            const cleanData = await getCleanData()
            // cleanData format: { .totalcomp, .papercount, .citationcount, .hindex }

            const leftMargin = 57
            const width = 1000
            const height = 900
            const yAxisPadding = 310

            const svg = d3.select('#container').append('svg').attr('width', width).attr('height', height)

            const dimensions = {
                totalcomp: { min: d3.min(cleanData, (d) => d.totalcomp), max: d3.max(cleanData, (d) => d.totalcomp) },
                hindex: { min: d3.min(cleanData, (d) => d.hindex), max: d3.max(cleanData, (d) => d.hindex) },
                papercount: { min: d3.min(cleanData, (d) => d.papercount), max: d3.max(cleanData, (d) => d.papercount) },
                citationcount: { min: d3.min(cleanData, (d) => d.citationcount), max: d3.max(cleanData, (d) => d.citationcount) },
            }

            const y = {}
            for (let dimension in dimensions) {
                y[dimension] = d3.scaleLinear().domain([dimensions[dimension].min, dimensions[dimension].max]).range([height, 0])
            }

            const colorScale = d3.scaleSequential(d3.interpolateTurbo).domain([dimensions.totalcomp.min, dimensions.totalcomp.max])

            const axis = svg
                .selectAll('.axis')
                .data(Object.keys(dimensions))
                .enter()
                .append('g')
                .attr('class', 'axis')
                .attr('transform', (d, i) => `translate(${i * yAxisPadding + leftMargin},0)`)
                .each(function (d) {
                    d3.select(this).call(d3.axisLeft().scale(y[d]))
                })

            axis.append('text')
                .style('text-anchor', 'middle')
                .attr('y', -9)
                .text((d) => d)
                .style('fill', 'black')
                .style('font-size', '12px')

            const line = d3
                .line()
                .defined((d) => !isNaN(d[1]))
                .x((d, i) => i * yAxisPadding + leftMargin)
                .y((d) => y[d[0]](d[1]))

            svg.selectAll('.line')
                .data(cleanData)
                .enter()
                .append('path')
                .attr('class', 'line')
                .attr('d', (d) => line(Object.keys(dimensions).map((p) => [p, d[p]])))
                .style('stroke', (d) => colorScale(d.totalcomp)) // Use the color scale to set the stroke color
                .style('stroke-width', 1)
                .style('fill', 'none')
        }
        main()
    </script>
</html>
